Функции исполняющей среды

Эти функции позволяют запрашивать и задавать различные параметры среды OpenMP:
omp_get_num_procs — возвращает число вычислительных узлов (процессоров/ядер) в компьютере.
omp_in_parallel — позволяет потоку узнать, занимается ли он в данный момент выполнением параллельного региона.
omp_get_num_threads — возвращает число потоков, входящих в текущую группу потоков.
omp_set_num_thread — задает число потоков для выполнения следующего параллельного региона, который встретится текущему выполняемому потоку. Функция может помочь распределить ресурсы. Например, если мы одновременно обрабатываем звук и видео на процессоре с четырьмя ядрами, то можно создать для звука один поток, а для обработки видео — три.
omp_get_max_threads — возвращает максимально допустимое число нитей для использования в следующей параллельной области.
omp_set_nested — разрешает или запрещает вложенный параллелизм. Если вложенный параллелизм разрешён, то каждая нить, в которой встретится описание параллельной области, породит для её выполнения новую группу нитей и станет в ней главной.
omp_get_nested — возвращает, разрешен ли вложенный параллелизм или нет.

Если имя функции начинается с omp_set_, то ее можно вызывать только вне параллельных регионов. Все остальные функции можно использовать как внутри параллельных регионов, так и вне таковых.

Функции синхронизации/блокировки

OpenMP позволяет строить параллельный код без использования этих функций, так как имеются директивы, позволяющие осуществлять определенные виды синхронизации. Однако в ряде случаев эти функции удобны и даже необходимы.

В OpenMP два типа блокировок: простые и вложенные. Вложенные имеют суффикс «nest». Блокировки могут находиться в одном из трех состояний — неинициализированном, заблокированном и разблокированном.
omp_init_lock/omp_init_nest_lock — инициализация переменной типа omp_lock_t/omp_nest_lock_t. Аналог InitializeCriticalSection.
omp_destroy_lock/omp_destroy_nest_lock — освобождение переменной типа omp_lock_t/omp_nest_lock_t. Аналог DeleteCriticalSection.
omp_set_lock/omp_set_nest_lock — один поток выставляет блокировку, а остальные потоки ждут, пока поток, вызвавшая эту функцию, не снимет блокировку с помощью функции omp_unset_lock(). Аналог EnterCriticalSection.
omp_unset_lock/omp_unset_nest_lock — снятие блокировки. Аналог LeaveCriticalSection.
omp_test_lock/omp_test_nest_lock — неблокирующая попытка захвата замка. Данная функция пробует захватить указанный замок. Если это удалось, то для простого замка функция возвращает 1. Если замок захватить не удалось, то возвращается 0. Аналог TryEnterCriticalSection.

Простые блокировки (omp_lock_t) не могут быть установлены более одного раза, даже тем же потоком. Вкладываемые блокировки (omp_nest_lock_t) идентичны простым с тем исключением, что когда поток пытается установить уже принадлежащую ему вкладываемую блокировку, он не блокируется.

Приведем пример кода, использующий описанные функции. Все создаваемые потоки по очереди выведут сообщения «Begin work» и «End work». Между этими двумя сообщениями от одного потока могут встретиться сообщения от других потоков, выводимых при неудачной попытке войти в закрытую секцию.

omp_lock_t lock;
int n;
omp_init_lock(&lock);
#pragma omp parallel private (n)
{
  n=omp_get_thread_num();
  while (!omp_test_lock (&lock))
  {
    printf("Wait..., thread %d\n", n);
    Sleep(3);
  }
  printf("Begin work, thread %d\n", n);
  Sleep(5); // Work...
  printf("End work, thread %d\n", n);
  omp_unset_lock(&lock);
}
omp_destroy_lock(&lock);


На машине с четырьмя ядрами может быть получен следующий вывод:

Begin work, thread 0
Wait..., thread 1
Wait..., thread 2
Wait..., thread 3
Wait..., thread 2
Wait..., thread 3
Wait..., thread 1
End work, thread 0
Begin work, thread 2
Wait..., thread 3
Wait..., thread 1
Wait..., thread 3
Wait..., thread 1
End work, thread 2
Begin work, thread 3
Wait..., thread 1
Wait..., thread 1
End work, thread 3
Begin work, thread 1
End work, thread 1

Функции работы с таймерами

omp_get_wtime — возвращает в вызвавшем потоке астрономическое время в секундах (вещественное число двойной точности — double), прошедшее с некоторого момента в прошлом. Если некоторый участок программы окружить вызовами данной функции, то разность возвращаемых значений покажет время работы данного участка.
omp_get_wtick() — возвращает в вызвавшем потоке разрешающую способность таймера в секундах, то есть точность таймера.

На этом знакомство с функциями мы завершим и рассмотрим парочку новых директив. Это директивы можно назвать опциями создаваемых параллельных регионов.

if (условие)

Выполнение параллельной области по условию. Создание нескольких потоков осуществляется только при выполнении некоторого условия. Если условие не выполнено, то код выполняется в последовательном режиме.

Пример использования:
void test(bool x)
{
  #pragma omp parallel if (x)
  if (omp_in_parallel())
  {
    #pragma omp single
    printf_s("parallelized with %d threads\n",
             omp_get_num_threads());
  }
  else
  {
    printf_s("single thread\n");
  }
}

int _tmain(int argc, _TCHAR* argv[])
{
  test(false);
  test(true);
  return 0;
}


Результат работы:
single thread
parallelized with 4 threads


num_threads

Явное задание количества потоков, которые будут выполнять параллельную область. По умолчанию выбирается последнее значение, установленное с помощью функции omp_set_num_threads().

Если мы модифицируем пример приведенный выше следующим образом:

...
#pragma omp parallel if (x) num_threads(3)
...


то получим следующий вывод:

single thread
parallelized with 3 threads
